// project1.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include "pch.h"
#include <iostream>
#include <stdarg.h>
#include <stdio.h>
#include <vector>
#include <list>
#include <WinSock2.h>
#include <map>
#pragma  comment(lib, "ws2_32.lib")

#pragma warning(disable : 4996)

int main()
{   
    //一：控制并发连入数量
    //epoll支持高并发：数万，数十万，百万【一台计算机】；
    //单纯探讨epoll支持多少并发连接，意义不是很大；
    //并发数量取决于很多因素：
    //(1)你采用的开发技术：epoll，支持数十万并发
    //(2)你这个程序收发数据的频繁程度，以及具体 要处理的业务复杂程度
    //(3)你实际的物理内存；可用的物理内存数量，会直接决定你能支持的并发连接
    //(4)一些其他的tcp/ip配置项，以后 有机会再谈；

    //一般，我们日常所写的服务器程序，支持几千甚至1-2万的并发，基本上就差不多了；
    //一个服务器程序，要根据我们具体的物理内存，以及我们具体要实现的业务等等因素，控制能够同时连入的客户端数量；
    //如果你允许客户端无限连入，那么你的服务器肯定会崩溃；
    //m_onlineUserCount
    //void CSocekt::ngx_event_accept(lpngx_connection_t oldc)   连入人数+1
    //void CSocekt::inRecyConnectQueue(lpngx_connection_t pConn) 连入人数-1
    //控制连入用户数量的解决思路：如果同时连入的用户数量超过了允许的最大连入数量时，我们就把这个连入的用户直接踢出去；

    //二：黑客攻击的防范
    //攻击效果
    //(1)轻则：服务器工作 延迟，效率明显降低
    //(2)重则整个服务器完全停摆，没有办法提供正常服务，比如拒绝服务攻击就会导致这种状况【服务器失去响应】；
    //(3)最甚者，如果你服务器程序写的有一些漏洞的话，恶意黑客很可能利用给一些远程溢出攻击手段直接攻破你的服务器程序所在的计算机；
    //能拿到一定的权限，甚至可能是 root权限，一旦拿到了root权限，那么你的整个计算机都在黑客控制中了；
    //但是，只要大家谨慎细心的写程序，这个漏洞可以避免；

    //有些攻击是利用tcp/ip协议先天的一些设计问题来攻击；【比如syn flood攻击】
    //DDOS攻击【syn flood攻击也是DDOS攻击的一种】甚至防火墙等设备都可能防不住，甚至得从数据路由器想办法；

    //我们的服务 程序，对于DDOS攻击，是没有办法解决的；但是我们写的程序，是能够解决一些用户三路握手连入进来后的一些网络安全问题；

    //（2.1）flood攻击防范
    //以游戏服务器为例；
    //假设我们认为一个合理的客户端一秒钟发送数据包给服务器不超过10个；
    //如果客户端不停的给服务器发数据包，1秒钟超过了10个数据包 ，那我服务器就认为这个玩家有恶意攻击服务器的倾向；
    //我们服务器就应该果断的把这个TCP客户端连接关闭，这个也是服务器发现恶意玩家以及保护自身安全的手段；
    //代码上如何实现 1秒钟超过10个数据包则把客户端踢出去；
    //增加了TestFlood();改造了ngx_read_request_handler(),ngx_wait_request_handler_proc_p1(),ngx_wait_request_handler_proc_plast（）

    //（2.2）畸形数据包防范
    //意识：客户端发送过来的数据并不可信，因为这些数据有可能是造假的，甚至可能是畸形的；
    //以游戏服务器为例；
    //(1)造假：服务器端书写的时候要细致判断，基本能够避免客户端造假；
    //(2)畸形数据包：远程溢出攻击，攻击成功的主要原因就是服务器程序书写不当，比如接收到的数据缺少边界检查；
    //以_HandleRegister()函数为例；
    //我们有必要在字符数组末尾 自己增加一个 \0【字符串结束标记】，以确保我们用这个字符数组的时候不会出问题；
    //p_RecvInfo->username[sizeof(p_RecvInfo->username) - 1] = 0;
    //p_RecvInfo->password[sizeof(p_RecvInfo->password) - 1] = 0; 

    //三：超时直接踢出服务器的需求
    //账号服务器；
    //账号服务器有一个需求：超过20秒不主动断开与本服务器连接的，那么本服务器就要主动的把这个用户踢下线（断开TCP连接）；
    //配置Sock_TimeOutKick=1,调整GetOverTimeTimer()函数；procPingTimeOutChecking();


}


