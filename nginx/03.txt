42 冲突的配置指令以谁为准？
---------------------------------------

(1)当一个指令出现在多个配置块中时,值是冲突的以谁为准
(2)没有这条指令,却生效了,怎样的机制?
(3)第三方模块不遵循官方配置规则,如何判断指令生效,或者冲突以谁为准

指令在多个block下可以合并:指令的合并
(1)值指令:存储配置项的值(解析配置时,对这个directive下,存储当时配置的值)
root,access_log,gzip可以合并
(2)动作类指令:指定行为
不可以合并,rewrite,proxy_pass
生效阶段:server_rewrite,rewrite(只有http的rewrite模块可以提供)
         content阶段(反向代理,5个content模块)

存储值的指令继承规则:向上覆盖
(1)子配置不存在时,直接使用父配置块
(2)子配置存在时,直接覆盖父配置块

HTTP模块合并配置的实现?
指令在那个block块下生效?
指令允许出现在那些块下?
在server块内生效,从http向server合并指令:char *(*merge_srv_conf)(ngx_conf_t* cf, void* prev, void* conf);
配置缓存在内存:char *(*merge_loc_conf)(ngx_conf_t* cf,void* prev, void* conf)

static ngx_command_t  ngx_http_referer_commands[] = {

    { ngx_string("valid_referers"),
      NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
      ngx_http_valid_referers,
      NGX_HTTP_LOC_CONF_OFFSET,
      0,
      NULL },

    { ngx_string("referer_hash_max_size"),
      NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
      ngx_conf_set_num_slot,
      NGX_HTTP_LOC_CONF_OFFSET,
      offsetof(ngx_http_referer_conf_t, referer_hash_max_size),
      NULL },

    { ngx_string("referer_hash_bucket_size"),
      NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
      ngx_conf_set_num_slot,
      NGX_HTTP_LOC_CONF_OFFSET,
      offsetof(ngx_http_referer_conf_t, referer_hash_bucket_size),
      NULL },

      ngx_null_command
};

static ngx_http_module_t  ngx_http_referer_module_ctx = {
ngx_http_referer_add_variables,        /* preconfiguration */
NULL,                                  /* postconfiguration */

NULL,                                  /* create main configuration */
NULL,                                  /* init main configuration */

NULL,                                  /* create server configuration */
NULL,                                  /* merge server configuration */

ngx_http_referer_create_conf,          /* create location configuration */
ngx_http_referer_merge_conf            /* merge location configuration */
};


43 - Listen指令的用法
-------------------------------------
从一个连接建立起,到收到请求


44 - 处理HTTP请求头部的流程
-------------------------------------

http模块处理请求之前,需要http框架都client建立好连接.然后接受http请求发过来的line(方法,url),
接受所有header,根据header信息才能决定使用哪些配置块,让http怎样处理请求

操作系统内核:                                   事件模块                         HTTP模块
client->SYN->server;
client<-SYN+ACK<-server;
client->ACK->server          负载均衡选中CPU上的worker
每个worker进程都监听80/443端口------>
                                       通过epoll_wait返回建立连接的句柄
                                       读事件?调用accept,分配连接内存池
                                       connection_pool_size 512     ------->    

client->DATA->server
client<-ACK<-server

HTTP模块
(1)ngx_http_init_connection设置回调方法                
(2)新建立连接读事件添加到epoll中,epoll_ctl方法
(3)添加超时定时器,表示如果60s没有收到请求超时,client_header_timeout 60s

(1)ngx_http_wait_request_hadler分配内存,ngx的data读取到用户态中,
内存从哪里分?从连接内存池子分
分多大?分配1k
如果url/header超过1k?

处理只把数据收到内存
处理请求需要做上下文分析,分析协议,分析header

接收URI
(1)分配请求内存池(request_pool_size:4k)
为什么分配4k?请求的上下文设计到业务,如果分配很小,需要请求内存池不断扩充
当分配内存次数变多,性能会下降
(2)状态机解析请求行(方法名,url,可能有url很大超过刚才分配的1K)
(3)分配大内存解决url太长,large_client_header_buffets:4 8k
先分配8k,把刚才1k内容拷过来,剩下7k接收http的url
如果8k没有接收完,接收16k,最大32k
(4)状态机解析请求行
(5)标示url.如果完整解析请求行,解析到\r\n,ngx很多变量不是复制一份,而是一个指针指向请求行,

接收header(cookie,host都很长)
(1)状态机解析header
(2)分配大内存,large_client_header_buffers:4 8k
(3)标识header,确定哪一个server块处理请求.
(3)移除超时定时器,client_header_timeout:60s
(4)开始11阶段的http请求处理

45 - Nginx中的正则表达式
-------------------------------------

$>wget https://ftp.pcre.org/pub/pcre/pcre-8.13.tar.gz
$>tar -xzvf  pcre-8.13.tar.gz
$>cd pcre-8.13 && ./configure --enable-utf8 && make
$>./pcretest
示例:\转义符号,取消元字符的特殊含义,()分组与取值
原始url:/admin/website/article/35/change/uploads/party/5.jpg
转换后的url:/static/uploads/party/5.jpg
匹配原始url的正则表达式:
/^\/admin\/website\/article\/(\d+)\/change\/uploads\/(\w+)\/(\w+)\.(png|jpg|gif|jpeg|bmp)$/

rewrite ^/admin/website/article/(d+)/change/uploads/(w+)/(w+).(png|jpg|gif|jpeg|bmp)$
 /static/uploads/$2/$3.$4 last;

location,server_name,rewrite指令如虎添翼


46 - 如何找到处理请求的server指令块
--------------------------------------------------

在处理11个http模块请求前,现决定哪一个server块被使用

主域名作用:server_name后面有多个域名,第一个是主域名,server_name_in_redict off时候主域名不生效

servername_test.conf
server {
    server_name primary.taohui.tech second.taohui.tech
    server_name_in_redirect off;

    return 302 /redict;
}

$>curl second.taohui.tech -I (server_name_in_redict off)
$>显示Location: http://second.taohui.tech/redict
$>curl second.taohui.tech -I (server_name_in_redict on)
$>显示Location: http://primary.taohui.tech/redict

server_name指令:
(1)指令后可以跟多个域名,第一个是主域名
Context http,server,location
(2)*泛域名:仅支持在最前或者最后 server_name *.tarhui.tech
(3)正则表达式:加~前缀 server_name www.taohui.tech ~^www\d+\.taohui\.tech;
(4)用正则表达式创建变量:用小括号()
(5).taohui.tech可以匹配taohui.tech *.taohui.tech
   _匹配所有
   "" 匹配没有传递Host头部
server {
    server_name ~^(www\.)?(.+)$;
    location / { root /sites/$2; }
}

server {
    server_name ~^(www\.)?(?<domain>.+)$;
    location / { rppt/sites/$domain; }
}

server匹配顺序
(1)精确匹配
(2)*在前的泛域名
(3)*在后的泛域名
(4)按文件中的顺序匹配正则表达式域名
(5)default server
    没有明确指定,第1个server块
    listen指定default

当ngx框架取到http的host头部时,可以用这个值与server块下server_name进行匹配.
按照相应顺序匹配一个server块时,这个server块下的所有http模块的指令就可以使用了


47 - 详解HTTP请求的11个阶段
----------------------------------------

当ngx接收完用户请求的header时候,按照11个阶段的顺序,一次调用每个阶段中的http模块.
当然每个阶段可能有多个http模块,他们之前的顺序也很重要

48 - 11个阶段的顺序处理
------------------------------------------
http请求进入这11个阶段,每个阶段可能有0个或者多个http模块.如果某个模块不在把请求向下传递,
后面的模块得不到执行
同一个阶段的多个模块,不一定都有机会执行到,可能会有前一个模块把请求传个下一个阶段中模块处理

(1)ngx_modules.c中char *ngx_module_names[]数组顺序,看出同一个阶段每个模块执行顺序相反
(2)rewrite,find_config,rewrite是ngx框架执行,第三方模块没有机会执行
如果access直接会跳到try_files模块阶段
index执行直接跳到,log模块阶段


49 - postread阶段：获取真实客户端地址的realip模块
-----------------------------------------------------

为后续模块实现限速,限流
(1)TCP连接四元组(src ip,src,port, dst ip,dst port)
(2)HTTP头部X-Forward-For用于传递IP
(3)HTTP头部X-Real-IP用于传递用户IP
(4)网络中存在许多反向代理

用户(路由器分配一个内网IP:192.168.0.x)
ADSL(运营商分配公网IP:115.204.33.1)
CDN(网站CDN,没有缓存我要的资源,然后回原,IP地址:1.1.1.1) []
某反向代理(IP地址2.2.2.2) [X-Forwarded-For:115.204.33.1 X-Real-IP:115.204.33.1]
Nginx remote_addr变量:2.2.2.2,用户地址:115.204.33.1[X-Forwarded-For:115.204.33.1 1.1.1.1 X-Real-IP:115.204.33.1]

拿到真实用户IP后如何使用?基于变量!!!
如binary_remote_addr,remote_addr这样的变量
(原来直接与ngx产生client连接的地址,但是经过realip模块改为X-Forwarded-For里面地址)
其值就为真实的IP!这样做连接限制(limit_conn模块)才有意义!
这也是为什limit_conn模块在preaccess阶段,而不在postread阶段


默认不会编译进Nginx
  --with-http_realip_module  enable ngx_http_realip_module
变量:realip_remote_addr,realip_remote_port
realip模块的指令:
(1)set_real_ip_from:只有是从CDN,或者是内网过来的IP地址,认为是可信的,所以
从他们的X-Forwarded-For取真正IP.
对于什么样的tcp连接的source ip,才能做替换remote_addr变量
(2)real_ip_header field | X-Real-IP | X-Forwarded-For |proxy_protocol
表示real ip从哪里面取出
(3)real_ip_recursive on | off;
环回地址
Default real_ip_recursive off;
如果打开,会把X-Forwarded-For最后的地址,和client地址相同,把它pass,取上一个地址
$>curl -H "X-Forwarded-For: 1.1.1.1,192.168.244.143 X-Real-IP: 1.0.0.0" 192.168.244.143
$>Client real ip: 192.168.244.143

real_ip_recursive on;设置
$>curl -H "X-Forwarded-For: 1.1.1.1,192.168.244.143 X-Real-IP: 1.0.0.0" 192.168.244.143
$>Client real ip: 192.168.244.143

因为处于postread阶段可以得到未经过处理的X-Forwarded-For/X-Real-IP里面的用户地址

50 - rewrite阶段的rewrite模块：return指令
-----------------------------------------------
http rewrite模块生成的return指令

Syntax:return code [text]    // text部分作为body
       return code URL    // URL作为重定向
       return URL

Default: --
Context： server,location,if
返回状态码:
HTTP 1.0标准
444:ngx立刻关闭连接,不会向用户返回内容
301:http1.0永久重定向
302:临时重定向,禁止被缓存
返回302浏览器不会对这次行为重定向.本来访问a,ngx给了一个b,不会做重定向.
下次访问a,再给重定向b,再去访问b结果
HTTP1.1标准
303:临时重定向,允许改变方法,禁止被缓存
307:临时定向,不允许改变方法,禁止被缓存
308:永久重定向,不允许改变方法

rewrite:return指令与error_page
Syntax:error_page code ...[=[response]]uri;
Default:-
C ontext:http,server,location,if inlocation

server与location块下的return指令关系?
执行server块下的return指令

return与error_page指令的关系?
执行server块下的return指令返回


51 - rewrite阶段的rewrite模块：重写URL
-----------------------------------------------------

Syntax: rewrite regex replacement[flag]
Default: -
Context: server,location,if
(1)将regex指令的url替换成replacement这个新的url
    --可以使用正则表达式及变量提取
(2)当replacement以http://或者https://或者$schema开头,则直接返回302重定向
(3)替换后的url根据flag指定的方式进行处理
   [1]last:用replacement这个URI进行新的loaction匹配
   [2]break:break指令停止当前脚本指令的执行,等价于独立的break指令
   [3]redirect:返回302重定向
   [4]permanent:返回301重定向


curl localhost:8082/first/3.txt
curl localhost:8082/second/3.txt
curl localhost:8082/third/3.txt

http://192.168.244.131:8082/redirect1/index.html
http://192.168.244.131:8082/redirect2/index.html
http://192.168.244.131:8082/redirect3/index.html
http://192.168.244.131:8082/redirect4/index.html

rewrite行为记入error日志
------------------------------------------------------
Syntax: rewrite_log on | off;
Default: rewrite_log off;
Context: http,server,location,if


52 - rewrite阶段的rewrite模块：条件判断
----------------------------------------------------
Syntax: if(condition) {...}
Default: --
Context: server,location
规则:条件condition为真,则执行大括号内的指令;遵循值指令的继承规则

53 - find_config阶段：找到处理请求的location指令块
----------------------------------------------------

(1)当server下的rewrite指令执行完成,根据请求的url根据location后面相对应的url前缀,或者正则表达式
进行匹配,匹配完成可以确定哪一个location,对这个请求处理

(2)
Syntax:    location [ = | ~ | ~* | ^~ ] uri { ... }
location @name { ... }
Default:    —
Context:    server, location

Syntax:    merge_slashes on | off;
Default:    
merge_slashes on;
Context:    http, server
把两个\\合并为一个\,base64编码的时候可以禁用

(3)location匹配规则
前缀字符串
[1]常规
[2]=:精确
[3]与这条url前缀匹配上后,不在进行正则表达式匹配
正则表达式

(4)ngx内部有一颗二叉树,存储所有前缀字符串
[1]匹配上=字符串,使用匹配上的=精确匹配location
[2]匹配^~字符串,使用匹配上的^~字符串location
[3]记住最长匹配的前缀字符串location
   按照nginx.conf中的顺序依次匹配正则表达式location
   匹配上->使用匹配上的正则表达式
   所有正则都不匹配->使用最长匹配的前缀字符串loction

$>curl 127.0.0.1:8083/Test1
 = /Test1 exact match!
$>curl 127.0.0.1:8083/Test1/
 ^~ /Test1/ stop regular expressions match!
$>curl 127.0.0.1:8083/Test1/Test
 ^~ /Test1/ stop regular expressions match!
$>curl 127.0.0.1:8083/Test1/Test2
 ~* /Test1/(\w+) longest regular expressions match!
 因为配置中location /Test1/Test2 前面没有禁止正则匹配^~
$>curl 127.0.0.1:8083/Test1/Test2/
 /Test1/Test2 longest prefix string match! 
$>curl 127.0.0.1:8083/test1/Test2/
 ~* /Test1/(\w+) longest regular expressions match!

1.location匹配规则
2.当location数量很多,怎样通过禁止正则表达式匹配/等于号等等,对于非常频繁发起的请求减少做location匹配次数
