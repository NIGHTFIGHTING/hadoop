nclude "pch.h"
#include <iostream>

using namespace std;
#pragma warning(disable : 4996)

int main()
{
    //一：fork()函数简单认识
    //创建进程；
    //进程的概念：一个可执行程序，执行起来就是一个进程，再执行起来一次，它就又是一个进程（多个进程可以共享同一个可执行文件）
    //文雅说法：进程 定义为程序执行的一个实例；

    //在一个进程（程序）中，可以用fork()创建一个子进程，当该子进程创建时，
    //它从fork()指令的下一条(或者说从fork()的返回处)开始执行与父进程相同的代码；

    //a)说白了：fork()函数产生了一个和当前进程完全一样的新进程，并和当前进程一样从fork()函数里返回；
    //原来一条执行通路（父进程），现在变成两条（父进程+子进程）

    //fork()：一分二； *********
    //（1.1）fork()函数简单范例
    //ps -eo pid,ppid,sid,tty,pgrp,comm,stat | grep -E 'bash|PID|nginx'
    //fork()之后，是父进程fork()之后的代码先执行还是子进程fork()之后的代码先执行是不一定的；这个跟内核调度算法有关；
    //kill子进程，观察父进程收到什么信号:SIGCHLD信号 ，子进程变成了僵尸进程Z

    //（1.2）僵尸进程的产生、解决，SIGCHLD
    //僵尸进程的产生：在Unix系统中，一个子进程结束了，但是他的父进程还活着，
    // 但该父进程没有调用(wait/waitpid)函数来进行额外的处置，那么这个子进程就会变成一个僵尸进程；
    //僵尸进程：已经被终止，不干活了，但是依旧没有被内核丢弃掉，因为内核认为父进程可能还需要该子进程的一些信息；
    //作为开发者，坚决不允许僵尸进程的存在；
    //如何干掉僵尸进程：
    //a)重启电脑
    //b)手工的把僵尸进程的父进程kill掉，僵尸进程就会自动消失；
    //SIGCHLD信号：一个进程被终止或者停止时，这个信号会被发送给父进程；
    //所以，对于源码中有fork()行为的进程，我们 应该拦截并处理SIGCHLD信号；
    //waitpid();

    //二：fork()函数进一步认识
    //b)fork()产生新进程的速度非常快，fork()产生的新进程并不复制原进程的内存空间，而是和
    //原进程（父进程)一起共享一个内存空间，但这个内存空间的特性是“写时复制”，也就是说：
    //原来的进程和fork()出来的子进程可以同时、自由的读取内存，但如果子进程（父进程）对
    //内存进行修改的话，那么这个内存就会复制一份给该进程单独使用，以免影响到共享这个内存空间的
    //其他进程使用；

    //三：完善一下fork()代码
    //fork()回返回两次：父进程中返回一次，子进程中返回一次,而且，fork()在父进程中返回的值和在子进程中返回的值是不同的
    //子进程的fork()返回值是0；
    //父进程的fork()返回值是新建立的子进程的ID，因为全局量g_mygbltest的值发生改变，导致主，子进程内存被单独的分开，所以每个的
    //g_mygbltest值也不同；

    //（3.1）一个和fork()执行有关的逻辑判断（短路求值）
    //||或：有1出1，全0出0；
    //&&与：全1出1，有0出0；

    //四：fork()失败的可能性
    //a)系统中进程太多
    //缺省情况，最大的pid：32767

    //b)每个用户有个允许开启的进程总数；
    //7788



}



