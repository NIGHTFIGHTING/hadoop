(1)平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数(它和CPU使用率并没有直接关系),它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。
(2)可运行状态的进程，是指正在使用CPU或者正在等待CPU的进程，ps命令:处于R状态（Running 或 Runnable）的进程
(3)不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的I/O响应，也就是我们在ps命令中看到的D状态（Uninterruptible Sleep，也称为Disk Sleep）的进程
(4)查看系统cpu核数:grep 'model name' /proc/cpuinfo | wc -l
(5)当平均负载高于 CPU 数量70%的时候，你就应该分析排查负载高的问题了。一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。把系统的平均负载监控起来，然后根据更多的历史数据，判断负载的变化趋势
(6)mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有CPU的平均指标
mpstat -P ALL 2 10
(7)pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。
pidstate -u 5 2,-u 显示cpu利用率
pidstate -d 5 2,-d 显示进程的io情况
(8)
watch -d uptime: -d会高亮显示变化的区域
stress: 压测命令，--cpu cpu压测选项，-i io压测选项，-c 进程数压测选项，--timeout 执行时间
(9)
[1]CPU密集型进程case：
stress --cpu 1 --timeout 600
mpstat -P ALL 5: -P ALL表示监控所有CPU，5表示每5秒刷新一次数据，观察是否有某个cpu的%usr会很高，但iowait应很低
pidstat -u 5 1：每5秒输出一组数据，观察哪个进程%cpu很高，但是%wait很低，极有可能就是这个进程导致cpu飚高
[2]IO密集型进程case：
stress -i 1 --timeout 600
mpstat -P ALL 5: 观察是否有某个cpu的%iowait很高，同时%usr也较高
pidstat -u 5 1：观察哪个进程%wait较高，同时%CPU也较高
[3]大量进程case：
stress -c 8 --timeout 600
pidstat -u 5 1：观察那些%wait较高的进程是否有很多,每个进程等待CPU的时间（也就是代码块中的 %wait 列 
等待 CPU使用率（%wait）

-----------------------------------------------------------------------------------------------------
4.
(1)vmstat主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数
vmstat命令的显示:
cs（context switch）是每秒上下文切换的次数
in（interrupt）则是每秒中断的次数
r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待CPU的进程数
b（Blocked）则是处于不可中断睡眠状态的进程数
(2)查看所有进程的上下文切换,pidstat -w 5
查看某个进程上下文切换,pidstat -w 5 -p 某个进程的pid
cswch:每秒自愿上下文切换次数，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换
nvcswch:每秒非自愿上下文切换的次数,是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换

------------------------------------------------------------------------------------------------------
5.
(1)
系统的CPU性能:CPU 使用率
(2)
Linux 作为一个多任务操作系统，将每个 CPU 的时间划分为很短的时间片，再通过调度器轮流分配给各个任务使用
(3)
Linux通过/proc虚拟文件系统，向用户空间提供了系统内部状态的信息，而/proc/stat 提供的就是系统的 CPU 和任务统计信息
proc/stat文件中每一列的顺序查询 man proc,数值是开机以来的节拍数累加值
user（通常缩写为us），代表用户态CPU时间。注意，它不包括下面的nice时间，但包括了guest时间。
nice（通常缩写为ni），代表低优先级用户态CPU时间，也就是进程的nice值被调整为1-19之间时的CPU时间。这里注意，nice可取值范围是-20到19，数值越大，优先级反而越低。
system（通常缩写为sys），代表内核态CPU时间。
idle（通常缩写为id），代表空闲时间。注意，它不包括等待I/O的时间（iowait）。
iowait（通常缩写为wa），代表等待I/O的CPU时间。
irq（通常缩写为hi），代表处理硬中断的CPU时间。
softirq（通常缩写为si），代表处理软中断的CPU时间。
steal（通常缩写为st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的CPU时间。
guest（通常缩写为guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的CPU时间。
guest_nice（通常缩写为gnice），代表以低优先级运行虚拟机的时间
CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比,公式:cpu使用率=1-空闲时间/总CPU时间
(4)
/proc/[pid]/stat,每个进程提供了运行情况的统计信息,man proc查看对应列含义
(5)
性能分析工具给出的都是间隔一段时间的平均 CPU 使用率，所以要注意间隔时间的设置，特别是用多个工具对比分析时，你一定要保证它们用的是相同的间隔时间
top 默认使用3秒时间间隔，而ps使用的却是进程的整个生命周期
(6)
查看 CPU 使用率的工具:
[1]top 显示了系统总体的 CPU 和内存使用情况，以及各个进程的资源使用情况。
  top默认显示的是所有CPU的平均值，这个时候你只需要按下数字1，就可以切换到每个CPU的使用率了
  top显示进程的实时信息，每个进程都有一个%CPU列，表示进程的CPU使用率。它是用户态和内核态 CPU 使用率的总和，包括进程用户空间使用的 CPU、通过系统调用执行的内核空间 CPU 、以及在就绪队列等待运行的 CPU。在虚拟化环境中，它还包括了运行虚拟机占用的 CPU。
  top没有细分进程的用户态CPU和内核态CPU
[2]
ps 则只显示了每个进程的资源使用情况,
(7)
pidstat是一个专门分析每个进程 CPU 使用情况的工具
用户态CPU使用率 （%usr）；
内核态CPU使用率（%system）；
运行虚拟机CPU使用率（%guest）；
等待 CPU使用率（%wait）；
以及总的CPU使用率（%CPU）
(8)
perf 是 Linux 2.6.31 以后内置的性能分析工具。它以性能事件采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问题
perf top，类似于 top，它能够实时显示占用 CPU 时钟最多的函数或者指令，因此可以用来查找热点函数
