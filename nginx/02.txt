20 Nginx的请求处理流程

(1)为什么讨论nginx的架构基础
nginx运行在企业的边缘节点,他处理的流量是应用服务器处理流量的数倍,甚至几个数量级
任何一种问题在不同数量级下的解决方案是不同的.所以在nginx处理场景中,任何一种问题都会被放大

为什么nginx采用master-worker架构模型?
为什么worker进程数量和cpu核数相匹配?
需要在多个worker间共享数据时候,为什么在TSL,或者一些限流限速场景,他们的共享方式是有所不同的?

Nginx请求处理流程:

(1)为什么称为状态机?
因为nginx使用非阻塞的事件驱动处理引擎(epoll),使用异步处理引擎需要使用状态机识别请求和处理

[1]处理4层TCP/UDP的传输层状态机
[2]处理应用的http状态机
[3]处理邮件Mail状态机

(2)每一种状态机在解析出请求,需要访问静态资源时候,对反向代理内容可以做磁盘缓存(proxy_pass,proxy_cache)
处理静态资源问题:当整个内存已经不足以完全缓存住所有的文件,缓存信息,sendfile,aio调用退化为阻塞的磁盘调用,使用线程池处理磁盘阻塞调用

对于每一个处理完的请求,记录access,error日志,记录在磁盘中,也可以通过syslog协议记录在远程机器
Nginx作为负载均衡,反向代理,把请求通过协议级传输后面的服务器,也可以通过应用层协议FastCGI,uWSGI,SCGI(python)代理到应用服务器


21 Nginx的进程结构
1.单进程:不适用于生产环境,只适用于开发调试
2.多进程:生成环境保证Nginx足够健壮,Nginx利用多核的特性
父进程:Master Process,子进程:cache,worker进程

为什为多进程结构,不是多线程?
Nginx要保证高可用性,高可靠性.如果使用多线程,线程之间共享同一块地址空间.当一个第三方模块引发一个地址空间导致
段错误时候,会导致整个nginx进程全部挂掉.采用多进程往往不会出现这个问题
第三方模块一般不会在Master Process加入自己代码,Master进程目的worker进程管理,所有的worker进程处理请求,

Master进程监控每个worker进程是否在工作,需不需要载入配置文件,需不需要做热部署
Cache缓存需要在多个Worker进程间共享,还被Cache Manager,Cache Loader进程使用
Cache Manager,Cache Loader为反向代理时候,后端发来的动态请求 做缓存所使用
Cache Loader作为缓存载入
Cache Manager作为缓存管理
这些进程间通信使用共享内存

为什么work进程很多?
Nginx采用事件驱动模型,希望每一个worker进程从头到尾,占有一颗cpu,不仅仅把worker进程数量配置和cpu合数一样
,还需要把每个cpu核与worker进程绑定,可以更好使用每一颗cpu上的cpu缓存,来减少缓存失效命中率

22 Nginx的进程结构实例演示
master作为父进程启动很多子进程,Nginx父子进程通过信号管理
ps -ef | grep nginx 看见当前进程id,和进程id
(1)./nginx -s reload把之前的worker,cache进程优雅退出,然后使用新的配置项,启动新的worker进程
reload与SIGHUP信号相同
kill -SIGHUP `cat nginx/logs/nginx.pid`
(2)向worker进程发送退出信号SIGQUIT,SIGINT,SIGTERM,worker进程退出向父进程master发送SIGCHILD信号,master进程知道子进程
退出了,重启一个worker进程

23 使用信号管理Nginx的父子进程

Nginx是一个多进程的程序,多进程通信可以使用共享内存,信号等
进程间管理使用信号
Master进程:
(1)监控worker进程CHILD,如果worker模块由于出现bug导致worker进程意外终止,master进程可以立刻通过CHILD信号,
重新把worker进程拉起
(2)接收信号管理worker进程,
TERM,INT立刻停止nginx进程
QUIT优雅停止nginx进程,保证对用户不发送立刻结束连接,不发送TCP-RESET复位请求报文
HUP重载配置文件
USR1重新打开日志文件,做日志文件切割
USR2
WINCH:热部署关闭老的worker进程

为什么不直接对work进程发送信号?
希望通过master进程管理worker进程
work进程
(1)接收信号TERM,INT,QUIT,USR1,WINCH

nginx命令行
启动nginx后,nginx把pid记在logs/nginx.pid,文件中记录master进程pid
执行./nginx -s 命令行,读取pid文件中master进程pid,向进程发送信号
reload:HUP
reopen:USR1
stop:TERM
quit:QUIT

24.reload重载配置文件的真相

(1)向master进程发送HUP信号(reload 命令)
(2)master进程校验配置语法是否正确
(3)master进程打开新的监听端口
(4)master进程用新配置启动新的worker子进程
(5)master进程向老worker子进程发送QUIT信号
(6)老worker进程关闭监听句柄,处理完当前连接结束进程

不停机载入新配置,nginx始终保持运行中,平滑的更换了配置文件 
(1)更新nginx.conf配置文件,向Master发送SIGHUP信号或者执行nginx -s reload
(2)Master使用新配置启动新的worker进程
(3)老配置Worker进程在完成已存在连接是优雅的退出

25.

热升级流程
(1)将旧Nginx文件换成新Nginx文件(注意备份)
(2)向master进程发送USR2信号
(3)master进程修改pid文件名,加后缀.oldbin
(4)master进程用新Nginx文件启动新master进程
(5)向老master进程发送WINCH信号,关闭老worker
(6)回滚:向老master发送HUP,向新master发送QUIT
