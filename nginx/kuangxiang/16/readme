// project1.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include "pch.h"
#include <iostream>
#include <stdarg.h>
#include <stdio.h>

using namespace std;
#pragma warning(disable : 4996)

int main()
{
    //一：守护进程功能的实现
    //三章二节  
    //(1)拦截掉SIGHUP，那么终端窗口关闭，进程就不会跟着关闭
    //(2)守护进程，三章七节，一运行就在后台，不会占着终端。
    //创建守护进程ngx_daemon（）；
    //调用ngx_daemon（）的时机： worker()子进程创建之前；
    //ps -eo pid,ppid,sid,tty,pgrp,comm,stat,cmd | grep -E 'bash|PID|nginx'
    //(1)一个master,4个worker进程，状态S，表示休眠状态，但没有+,+号表示位于前台进程组，没有+说明我们这几个进程不在前台进程组；
    //(2)master进程的ppid是1【老祖宗进程init】，其他几个worker进程的父进程都是master；
    //(3)tt这列都为？，表示他们都脱离了终端，不与具体的终端挂钩了
    //(4)他们的进程组PGRP都相同；

    //结论：
    //1)守护进程如果通过键盘执行可执行文件来启动，那虽然守护进程与具体终端是脱钩的，但是依旧可以往标准错误上输出内容，这个终端对应的屏幕上可以看到输入的内容；
    //2)但是如果这个nginx守护进程你不是通过终端启动，你可能开机就启动，那么这个nginx守护进程就完全无法往任何屏幕上显示信息了，这个时候，要排错就要靠日志文件了；

    //二：信号处理函数的进一步完善
    //（2.1）避免子进程被杀掉时变成僵尸进程
    //父进程要处理SIGCHILD信号并在信号处理函数中调用waitpid()来解决僵尸进程的问题；
    //信号处理函数中的代码，要坚持一些书写原则：
    //a)代码尽可能简单，尽可能快速的执行完毕返回；
    //b)用一些全局量做一些标记；尽可能不调用函数；
    //c)不要在信号处理函数中执行太复杂的代码以免阻塞其他信号的到来，甚至阻塞整个程序执行流程；


}



