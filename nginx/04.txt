82.反向代理与负载均衡原理
------------------------------------------------------
http模块7层反向代理
stream模块4层反向代理

一个请求到达nginx,g到转发上游服务,转发客户端
1)负载均衡
ngx为一个应用服务集群,g提升应用服务的可用性.包括容灾和扩容
可扩展性如何通过ngx保护的?
Nginx在AKF扩展立方体上的应用
1]X轴扩展:我们的服务是无状态的,g无论启多少个服务,他们是同等为用户请求服务的
称为水平扩展,g成本最低.nginx的round-robin/least-conected是基于水平扩展的算法
水平扩展不能解决所有问题,g尤其是不能解决数据量问题.单台数据量大的时候,无论扩展多少台服务,i
每一台服务数据依然非常大
2]Y轴进行拆分:原来有一台应用服务处理的功能,g分为两台应用服务.分别处理不同的api(处理不同的url)
nginx可以基于URL的location进行配置,g有些location可以通过proxy_pass代理到上游服务器中.对功能进行分发
需要更改代码,g做大量重构,成本比较高
3]Z轴基于用户信息进行扩展:
比如可以基于用户ip地址,g我们的cdn.发现某一些ip地址靠近某一个cdn中心.可以把这样的请求引流到这个cdn
上,g
为了分离减少数据容量,g可以根据用户名,某些固定用户引流到固定集群
nginx的hash算法可以用于基于Z轴扩展

反向代理分为两大类:
4层
7层:http中含有大量业务信息,g当client发来http请求后,根据http的header,method等等信息,
可以转换为不同协议

2)缓存
1]时间缓存:用户方位 index.html通过internet网,g到达nginx,index.html在nginx没有缓存所以访问,所以
访问应用服务器.应用服务器的响应到达nginx,gnginx做两件事,nginx把respose发给用户;把相应缓存在
这台机器的磁盘上
当另一个用户请求index.html,gnginx发现这个页面已经缓存,且在缓存有效期内,直接响应用户.减少环节,
且nginx比应用服务器性能更好
2]空间缓存
当访问应用服务器内容,gnginx可以加快速度欲取一些响应的内容,放在nginx上

链接：https://www.jianshu.com/p/d08d0c14810f
AKF扩展立方体（Scalability Cube），是《架构即未来》一书中提出的可扩展模型，这个立方体有三个轴线，每个轴线描述扩展性的一个维度，他们分别是产品、流程和团队：
X轴 —— 代表无差别的克隆服务和数据，工作可以很均匀的分散在不同的服务实例上；
Y轴 —— 关注应用中职责的划分，比如数据类型，交易执行类型的划分；
Z轴 —— 关注服务和数据的优先级划分，如分地域划分。

链接:https://www.cnblogs.com/zhyg/p/9466998.html
X,gY,Z轴分别代表了不同的扩展方向，下面简单解释一下：
1)X轴代表无差别的克隆服务和数据库。用一个人来说X轴的例子可能是公司很多相同的事情分给多个人来干，简单快捷在每个克隆实体间无差别的分配任务，每个克隆实体都可以完成其他克隆实体的任务，无论任务分配给了谁。每个克隆实体都有工具和资源来尽快完成所分配的任务。
2)Y轴代表的是按照交易处理的数据类型，交易任务类型或两者组合分割的工作责任。我们一般用动词或资源进行分离，比如：登录，查询，结算等等。把同样的工作分割成流水线式的工作流或并行的处理流，Y轴代表的更多是对工作的“工业革命”，将耦合紧密的工作进行进行专门处理。Y轴实质代表责任、行动或数据。实施成本一般比X轴扩展代价高。假如有100个人造100辆车，每个人负责造一辆，完成造车全部的任务，不如让100个人执行子任务，如发送机的安装、喷漆、四轮定位。这样就会减少前后交互所需要的上下文信息，更专注做某件事情。
3)Z轴通常基于请求或客户的信息进行分割。比如我们在分客户时会有 “普通会员”和“vip会员“之分，服务“普通会员”与服务“vip会员”可能会有不同。vip会员可能会特殊对待，会有单独的人在处理vip会员的事情。但是他们都是会员。再比如一些客户可能需要专门的账单、付款条件和基于业务量的特别互动。我们可能安排最好的财务代表、甚至特别的经理负责一个或多个客户，以专门处理他们的独特需求。这样将减少执行绝大多数的计费功能所需的知识量，从而服务好广大客户。Z轴分割是成本最高的分割方向，Z轴分割有助于提高交易和数据的可扩展性，如果实施得当也有助于扩展指令集和过程

X轴一般就是负载均衡，比如用F5等硬件设备进行端口轮训负载。
Y轴主要体现在我们按业务拆分服务，比如登录服务，订单服务等
Z轴主要是对一些有特殊要求的业务执行单独流程处理，比如按地区提供对应地区客户的服务，根据不同地区不同客户群的生活习惯等进行差异化服务。 


83.负载均衡策略：round-robin
-----------------------------------------------------
(1)指定上游服务地址的upstream与server指令

Syntax: upstream name { ... }
Default: -
Context: http

Syntax: server address [parameters]
Default: -
Context: upstream

功能:指定一组上游服务器地址,其中,地址可以是域名,IP地址或者unix socket地址.可以在域名或者IP地址后加端口,如果不加端口,那么默认使用80端口
通用参数:
backup指定当前server为备份服务,仅当非备份server不可用时,请求才会转发到该server
down:表示某台服务已经下线,不在服务

(2)加权Round-Robin负载均衡算法
功能:在加权轮询的方式访问server指令指定的上游服务
集成在Nginx的upstream框架中

weight
服务访问的权重,默认是1
max_conns
server的最大并发连接数,仅用于单worker进程,默认是0,表示没有限制
max_fails
在fail_timeout时间段内,最大的失败次数.当达到最大失败时,会在fail_timeout秒内这台server不允许再次被选择
fail_timeout
单位为秒,默认值为10秒,具有2个功能:
指定一段时间内,最大的失败次数max_fails.
到达max_fils后,改server不能访问的时间.

83_roundrobin.conf
83_upserver.conf


84.负载均衡哈希算法：ip_hash与hash模块
-------------------------------------------------------------

round-robin无法保证某一类请求只能由某一台服务器处理,只能做AKF中的X轴水平扩展
基于Z轴扩展:hash算法

基于客户端IP地址的Hash算法实现负载均衡:upstream_ip_hash模块
功能:以客户端的IP地址作为hash算法的关键字,映射到特定的上游服务器中.
对IPV4地址使用前3个字节作为关键字,对IPV6使用完整地址
可以使用round-robin算法的参数
可以基于realip模块修改用于执行算法的IP地址

Syntax: ip_hash;
Default: -
Context: upstream
模块:ngx_http_upstream_ip_hash_module,通过--without-http_upstream_ip_hash_module禁用模块
基于任意关键字实现Hash算法的负载均衡:upstream_hash模块
功能:通过指定关键字作为hash key.
    基于hash算法映射到特定的上游服务器中.(关键字可以含有变量,字符串;可以使用round-robin算法的参数)
模块:ngx_http_upstream_hash_module,通过--without-http_upstream_hash_module禁用模块
Syntax: hash key [consistent];
Default: -
Context: upstream

84_iphash.conf
hash key
$>curl -H "X-Forwarded-For: 1.1.1.1" 192.168.244.131:8100?username=x11111asdadsadssa
$>curl -H "X-Forwarded-For: 1.1.1.1" 192.168.244.131:8100?username=x11111

使用hash算法可以保证某一类请求,只路由到某一台上游服务中,无论这台上游服务是否正常在线,当一台
上游服务线下,损坏了,不能直接把这台server直接从upstream配置中移除.因为移除后,导致它的hash算法
发生变化,同时影响到路由到其他server的请求也发生变化.一致性hash算法可以缓解这个问题.

85.一致性哈希算法：hash模块
---------------------------------------------------------

当上游服务器数量发生变化时,它的路由策略失效,一致性hash能缓解这个问题 
宕机或者扩容时,hash算法引发大量路由变更,可能导致缓存大范围失效

4台server放在一个环上,任何一个键key计算hash会有一个值.4个节点按照整数,比如hash全是32为整型,
4个节点均匀的放在环上.分的力度很细,假如在扩容,影响范围很小
当上游服务使用缓存时,会导致缓存失效.不能解决宕机或者扩容,所有路由不能发生变化,这个解决不了

使用一致性hash算法: upstream_hash模块 
Syntax: hash key [consistent];
Default: -
Context: upstream

86.最少连接算法以及如何跨worker进程生效
---------------------------------------------------------
优先选择连接最少的上游服务器
upstream_least_conn模块
功能:从所有上游服务器中,找出当前并发连接数量少的一个,将请求转发给它
如果出现多个最少连接服务器的连接数都是一样的.使用round-robin算法.
模块:
ngx_http_upstream_least_conn_module,通过--without-http_upstream_least_conn_module禁用模块
Syntax:least_conn;
Default: -
Context: upstream

原来讲的负载均衡算法默认只在一个worker进程生效,因为放在内存中.使用共享内存,上游服务器的信息
以及当前状态信息全部存放在共享内存中
使用共享内存使负载均衡对所有worker进程生效:upstream_zone模块
功能:分配出共享内存,将其他upstream模块定义的负载均衡策略数据,运行时每个上游服务的状态数据存放在
共享内存上,以对所有nginx worker进程生效.
模块:ngx_http_upstream_zone_module,通过--without-http_upstream_ip_hash_module禁用
Syntax: zone name [size];
Default: -
Context: upstream

upstream模块间的顺序:功能的正常运行
用共享内存替代原先的内存存储,解决了多个worker进程之间共享配置,共享负载均衡算法能力

ngx_module_t *ngx_modules[] {
    ... ...
    &ngx_http_upstream_hash_module,    
    &ngx_http_upstream_ip_hash_module,    
    &ngx_http_upstream_least_conn_module,    
    &ngx_http_upstream_keepalive_module,    
    &ngx_http_upstream_zone_module, 
    ... ...
};

87.http upstream模块提供的变量
-------------------------------------------------------
不含有缓存的变量


88.http反向代理proxy处理请求的流程
-------------------------------------------------------
proxy模块从客户端接收http协议,转发给上游也是http协议



89.proxy模块中的proxy_pass指令
-------------------------------------------------------

对HTTP协议的方向代理:proxy模块
URL参数规则:
(1)URL必须以http://或者https://开头,接下来是域名,IP,unix socket地址或者upstream的名字,
前两者可以在域名或者IP后加端口,最后是可选的URI

(2)当URI参数中携带URI与否,会导致发向上游请求的URL不同:
   [1]不携带URI,则将客户端请求中的URL直接装发给上游
      -location后使用正则表达式,@名字时,应采用这种方式
   [2]携带URI,则对用户请求中的URL作如下操作:
      -将location参数中匹配上的一段替换为改URI
(3)该URL参数中可以携带变量
(4)更复杂的URL替换,可以在location内的配置添加rewrite break语句



90.根据指令修改发往上游的请求
--------------------------------------------------------

http_proxy为上游生成请求时,提供很多指令.这些指令怎样修改转发给上游请求的内容.

proxy_pass是动作类指令,指定在某一个阶段中,直接使用proxy模块处理请求

90_proxy.conf
90_upserver.conf

$>curl -H 'name: myname' lcalhost:8101/a

(1)proxy模块:生成发往上游的请求行
Syntax: proxy_method method;
Default: -
Context: http,server,location

Syntax: proxy_http_version 1.0|1.1;
Default: proxy_http_version 1.0;
Context: http,server,location

(2)proxy模块:生成发往上游的请求头部
Syntax: proxy_set_header field value;
        proxy_set_header Host $proxy_host;
Context: http,server,location

注意:若value的值为空字符串,则整个header都不回想上游发送

Syntax: proxy_pass_request_headers on|off;
Default: proxy_pass_request_headers on;
Context: http,server,location

Syntax: proxy_pass_request_body on|off;
Default: proxy_pass_request_body on;
Context: http,server,location

Syntax: proxy_set_body value;
Default: -
Context: http,server,location

构造发往上游服务器请求内容,会影响上游服务器怎样处理这个请求.包括缓存,Host头部,keep-alive

91.接收用户请求包体的方式
--------------------------------------------------
