// project1.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include "pch.h"
#include <iostream>
#include <stdarg.h>
#include <stdio.h>
#include <vector>
#include <list>

using namespace std;
#pragma warning(disable : 4996)


int main()
{   
    //一：收包分析及包头结构定义
    //发包：采用 包头+包体，其中包头中记录着整个包【包头—+包体】的长度；
    //包头：就是一个结构；
    //a)一个包的长度不能超过30000个字节，必须要有最大值；
    //伪造恶意数据包，他规定这里300亿，我这个规定能够确保服务器程序不会处于非常危险的境地；
    //b)开始定义包头结构：COMM_PKG_HEADER
    //c)********************大家千万注意这个问题，不然会大错特错；
    //结构字节对齐问题；为了防止出现字节问题，所有在网络上传输的这种结构，必须都采用1字节对齐方式***********

    //二：收包状态宏定义
    //收包：粘包，缺包；
    //收包思路：先手包头->根据包头中的内容确定包体长度并收包体，收包状态（状态机）；
    //定义几种收包的状态, 4种：0,1,2,3

    //三：收包实战代码
    //聚焦在ngx_wait_request_handler()函数；
    //同时设置好各种收包的状态：c->curStat = _PKG_HD_INIT;    c->precvbuf = c->dataHeadInfo;  c->irecvlen = sizeof(COMM_PKG_HEADER); 
    //我们要求，客户端连入到服务器后，要主动地【客户端有义务】给服务器先发送数据包；服务器要主动收客户端的数据包；
    //服务器按照 包头 + 包体的格式来收包；

    //引入一个消息头【结构】STRUC_MSG_HEADER，用来记录一些额外信息
    //服务器 收包时，  收到： 包头+包体  ，我再额外附加一个消息头 ===》  消息头 + 包头 + 包体
    //再介绍一个分配和释放内存类CMemory；
    //本项目中不考虑内存池； 内存池：对于提高程序运行效率帮助有效；new非常快；
    //    内存池主要功能就是 频繁的分配小块内存时 内存池可以节省额外内存开销【代价就是代码更复杂】；

    //四：遗留问题处理
    //inMsgRecvQueue，tmpoutMsgRecvQueue，clearMsgRecvQueue

    //五：测试服务器收包避免推诿扯皮
    //验证ngx_wait_request_handler()函数是否正常工作,准备写一个客户端程序；
    //windows vs2017 ，mfc程序
    //老师强制大家要写测试程序来测试；你可以写linux平台下的测试程序；
    //觉悟：服务器主程序员【重担压肩】；
    //防止扯皮，所以服务器端有必要自己书写一个客户端测试程序；
    //说明：windows vs2017 客户端测试代码，非常简陋，只用于演示目的，不具备商业代码质量；
    //客户端的 SendData()函数值得学习；
    //核心代码;MFCApplication3Dlg.cpp


}



