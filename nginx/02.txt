20 Nginx的请求处理流程

(1)为什么讨论nginx的架构基础
nginx运行在企业的边缘节点,他处理的流量是应用服务器处理流量的数倍,甚至几个数量级
任何一种问题在不同数量级下的解决方案是不同的.所以在nginx处理场景中,任何一种问题都会被放大

为什么nginx采用master-worker架构模型?
为什么worker进程数量和cpu核数相匹配?
需要在多个worker间共享数据时候,为什么在TSL,或者一些限流限速场景,他们的共享方式是有所不同的?

Nginx请求处理流程:

(1)为什么称为状态机?
因为nginx使用非阻塞的事件驱动处理引擎(epoll),使用异步处理引擎需要使用状态机识别请求和处理
[1]处理4层TCP/UDP的传输层状态机
[2]处理应用的http状态机
[3]处理邮件Mail状态机

(2)每一种状态机在解析出请求,需要访问静态资源时候,对反向代理内容可以做磁盘缓存(proxy_pass,proxy_cache)
处理静态资源问题:当整个内存已经不足以完全缓存住所有的文件,缓存信息,sendfile,aio调用退化为阻塞的磁盘调用,使用线程池处理磁盘阻塞调用

对于每一个处理完的请求,记录access,error日志,记录在磁盘中,也可以通过syslog协议记录在远程机器
Nginx作为负载均衡,反向代理,把请求通过协议级传输后面的服务器,也可以通过应用层协议FastCGI,uWSGI,SCGI(python)代理到应用服务器


21 Nginx的进程结构
1.单进程:不适用于生产环境,只适用于开发调试
2.多进程:生成环境保证Nginx足够健壮,Nginx利用多核的特性
父进程:Master Process,子进程:cache,worker进程

为什为多进程结构,不是多线程?
Nginx要保证高可用性,高可靠性.如果使用多线程,线程之间共享同一块地址空间.当一个第三方模块引发一个地址空间导致
段错误时候,会导致整个nginx进程全部挂掉.采用多进程往往不会出现这个问题
第三方模块一般不会在Master Process加入自己代码,Master进程目的worker进程管理,所有的worker进程处理请求,

Master进程监控每个worker进程是否在工作,需不需要载入配置文件,需不需要做热部署
Cache缓存需要在多个Worker进程间共享,还被Cache Manager,Cache Loader进程使用
Cache Manager,Cache Loader为反向代理时候,后端发来的动态请求 做缓存所使用
Cache Loader作为缓存载入
Cache Manager作为缓存管理
这些进程间通信使用共享内存

为什么work进程很多?
Nginx采用事件驱动模型,希望每一个worker进程从头到尾,占有一颗cpu,不仅仅把worker进程数量配置和cpu合数一样
,还需要把每个cpu核与worker进程绑定,可以更好使用每一颗cpu上的cpu缓存,来减少缓存失效命中率

22 Nginx的进程结构实例演示
master作为父进程启动很多子进程,Nginx父子进程通过信号管理
ps -ef | grep nginx 看见当前进程id,和进程id
(1)./nginx -s reload把之前的worker,cache进程优雅退出,然后使用新的配置项,启动新的worker进程
reload与SIGHUP信号相同
kill -SIGHUP `cat nginx/logs/nginx.pid`
(2)向worker进程发送退出信号SIGQUIT,SIGINT,SIGTERM,worker进程退出向父进程master发送SIGCHILD信号,master进程知道子进程
退出了,重启一个worker进程

23 使用信号管理Nginx的父子进程

Nginx是一个多进程的程序,多进程通信可以使用共享内存,信号等
进程间管理使用信号
Master进程:
(1)监控worker进程CHILD,如果worker模块由于出现bug导致worker进程意外终止,master进程可以立刻通过CHILD信号,
重新把worker进程拉起
(2)接收信号管理worker进程,
TERM,INT立刻停止nginx进程
QUIT优雅停止nginx进程,保证对用户不发送立刻结束连接,不发送TCP-RESET复位请求报文
HUP重载配置文件
USR1重新打开日志文件,做日志文件切割
USR2
WINCH:热部署关闭老的worker进程

为什么不直接对work进程发送信号?
希望通过master进程管理worker进程
work进程
(1)接收信号TERM,INT,QUIT,USR1,WINCH

nginx命令行
启动nginx后,nginx把pid记在logs/nginx.pid,文件中记录master进程pid
执行./nginx -s 命令行,读取pid文件中master进程pid,向进程发送信号
reload:HUP
reopen:USR1
stop:TERM
quit:QUIT

24.reload重载配置文件的真相
